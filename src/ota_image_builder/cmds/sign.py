# Copyright 2025 TIER IV, INC. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import json
import logging
import sys
import typing
from base64 import urlsafe_b64encode
from hashlib import sha256
from pathlib import Path
from typing import TYPE_CHECKING

from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
from cryptography.x509 import load_pem_x509_certificate
from ota_image_libs._crypto.x509_utils import X5cX509CertChain
from ota_image_libs.v1.consts import INDEX_JWT_FNAME
from ota_image_libs.v1.image_index.utils import ImageIndexHelper
from ota_image_libs.v1.index_jwt.utils import compose_index_jwt

from ota_image_builder._common import check_if_valid_ota_image, exit_with_err_msg
from ota_image_builder._consts import EMPTY_FILE_SHA256

if TYPE_CHECKING:
    from argparse import ArgumentParser, Namespace, _SubParsersAction


logger = logging.getLogger(__name__)


def load_cert_chains(ee_fpath: Path, ca_fpaths: list[Path]) -> X5cX509CertChain:
    _res = X5cX509CertChain()
    _res.add_ee(load_pem_x509_certificate(ee_fpath.read_bytes()))
    if ca_fpaths:
        _res.add_interms(
            *[load_pem_x509_certificate(_ca_f.read_bytes()) for _ca_f in ca_fpaths]
        )
    return _res


def sign_image(
    image_root: Path,
    *,
    sign_cert_chain: X5cX509CertChain,
    sign_key: bytes,
    force_sign: bool,
    sign_key_passwd: bytes | None = None,
) -> None:
    """Sign the image, and write the output index.jwt into the OTA image root."""
    _index_helper = ImageIndexHelper(image_root)
    if not _index_helper.image_index.image_finalized:
        exit_with_err_msg(
            "ERR: image is not yet finalized, thus cannot be signed, abort!"
        )
    _index_helper.image_index.finalize_signing_image(force_sign=force_sign)
    _, _index_descriptor = _index_helper.sync_index()

    _index_jwt = compose_index_jwt(
        _index_descriptor,
        sign_cert_chain=sign_cert_chain,
        sign_key=sign_key,
        sign_key_passwd=sign_key_passwd,
    )
    _index_jwt_f = image_root / INDEX_JWT_FNAME
    _index_jwt_f.write_text(_index_jwt)


#
# ------ Legacy OTA Image compatibility support ------ #
#

METADATA_JWT_FNAME = "metadata.jwt"
CERTIFICATE_FNAME = "certificate.pem"


def _generate_dummy_metadata_jwt(
    *,
    sign_cert_bytes: bytes,
    sign_key: bytes,
    sign_key_passwd: bytes | None = None,
) -> str:
    """
    NOTE: the JWT generated by this method DOESN'T follow JWT spec, but follows
          how the JWT is generated in the legacy OTA image spec.
          That is an unfortune of the legacy OTA image specification.
    """
    _cert_digest = sha256(sign_cert_bytes).hexdigest()
    # NOTE: only support ecdsa algorithm!
    _loaded_priv_key = typing.cast(
        ec.EllipticCurvePrivateKey,
        load_pem_private_key(sign_key, password=sign_key_passwd),
    )

    _header_b64_encoded = urlsafe_b64encode(
        json.dumps(
            {
                "alg": "ES256",
                "typ": "JWT",
            }
        ).encode()
    )
    _payload_b64_encoded = urlsafe_b64encode(
        json.dumps(
            [
                {"version": 1},  # must
                {"directory": "dirs.txt", "hash": EMPTY_FILE_SHA256},  # must
                {"symboliclink": "symlinks.txt", "hash": EMPTY_FILE_SHA256},  # must
                {"regular": "regulars.txt", "hash": EMPTY_FILE_SHA256},  # must
                {"persistent": "persistents.txt", "hash": EMPTY_FILE_SHA256},  # must
                {"certificate": CERTIFICATE_FNAME, "hash": _cert_digest},  # must
                {"rootfs_directory": "data"},
                {"total_regular_size": "0"},
                {"compressed_rootfs_directory": "data.zstd"},
            ]
        ).encode()
    )
    _sign_b64_encoded = urlsafe_b64encode(
        _loaded_priv_key.sign(
            b".".join([_header_b64_encoded, _payload_b64_encoded]),
            signature_algorithm=ec.ECDSA(
                hashes.SHA256(),
            ),
        )
    )
    return ".".join(
        [
            _header_b64_encoded.decode("utf-8"),
            _payload_b64_encoded.decode("utf-8"),
            _sign_b64_encoded.decode("utf-8"),
        ]
    )


def _add_compat_to_image(
    image_root: Path,
    *,
    cert_bytes: bytes,
    sign_key: bytes,
    sign_key_passwd: bytes | None = None,
) -> None:
    cert_save_dst = image_root / CERTIFICATE_FNAME
    metadata_jwt_save_dst = image_root / METADATA_JWT_FNAME

    cert_save_dst.write_bytes(cert_bytes)
    metadata_jwt_save_dst.write_text(
        _generate_dummy_metadata_jwt(
            sign_cert_bytes=cert_bytes,
            sign_key=sign_key,
            sign_key_passwd=sign_key_passwd,
        )
    )


# ------------------------ #


def sign_cmd_args(
    sub_arg_parser: _SubParsersAction[ArgumentParser], *parent_parser: ArgumentParser
) -> None:
    sign_cmd_arg_parser = sub_arg_parser.add_parser(
        name="sign",
        help=(_help_txt := "Sign an OTA image with sign cert chain and sign key"),
        description=_help_txt,
        parents=parent_parser,
    )
    sign_cmd_arg_parser.add_argument(
        "--sign-cert",
        help="OTA image signing cert in X509 PEM format.",
        required=True,
    )
    sign_cmd_arg_parser.add_argument(
        "--sign-key",
        help="OTA image signing key in PEM format. "
        "This arg takes either a file path, or plain PEM format private key string. "
        "It also takes `-`, ota-image-builder then will take the private key string from stdin.",
        required=True,
    )
    sign_cmd_arg_parser.add_argument(
        "--sign-key-passwd",
        default=None,
        help="If private key is protected by passphrase.",
    )
    sign_cmd_arg_parser.add_argument(
        "--ca-cert",
        action="append",
        help="Intermediate CA certs in X509 PEM format for cert chain, can be specified multiple times.",
    )
    sign_cmd_arg_parser.add_argument(
        "--force-sign",
        help="If specified, force signing an already signed OTA image.",
        action="store_true",
    )
    sign_cmd_arg_parser.add_argument(
        "--legacy-compat",
        help="If specified, a signed dummy metadata.jwt will be generated. "
        "This option is only meaningful when add-otaclient-package-compat has been called once.",
        action="store_true",
    )
    sign_cmd_arg_parser.add_argument(
        "image_root",
        help="The folder to hold a new empty OTA image. It should be an empty folder.",
    )
    sign_cmd_arg_parser.set_defaults(handler=sign_cmd)


def _load_private_key(_in: str | None) -> bytes:
    if not _in:
        exit_with_err_msg("empty input sign key, abort!")

    if _in.startswith("-----BEGIN"):
        return _in.encode()
    if _in == "-":
        try:
            return sys.stdin.buffer.read()
        except Exception as e:
            exit_with_err_msg(f"failed to read private key from stdin: {e!r}")

    try:
        return Path(_in).read_bytes()
    except FileNotFoundError:
        exit_with_err_msg("the specified key file doesn't exist!")
    except Exception as e:
        exit_with_err_msg(f"failed to read private key: {e!r}")


def sign_cmd(args: Namespace) -> None:
    logger.debug(f"calling {sign_cmd.__name__} with {args}")
    image_root = Path(args.image_root)
    if not check_if_valid_ota_image(image_root):
        exit_with_err_msg(f"{image_root} doesn't hold a valid OTA image.")

    sign_cert_f = Path(args.sign_cert)
    ca_certs_fs = [Path(_ca_cert) for _ca_cert in args.ca_cert]

    if not sign_cert_f.is_file():
        exit_with_err_msg(f"{sign_cert_f=} not found.")
    for _ca_cert in ca_certs_fs:
        if not _ca_cert.is_file():
            exit_with_err_msg(f"CA cert {_ca_cert} is specified, but not found.")

    try:
        loaded_cert_chain = load_cert_chains(sign_cert_f, ca_certs_fs)
    except Exception as e:
        logger.debug(f"failed to load sign cert chain: {e}", exc_info=e)
        exit_with_err_msg(
            f"failed to load sign cert chain {sign_cert_f} and {ca_certs_fs}"
        )

    logger.info(f"Will sign OTA image at {image_root} ...")

    sign_key_passwd = args.sign_key_passwd.encode() if args.sign_key_passwd else None
    sign_key = _load_private_key(args.sign_key)
    try:
        sign_image(
            image_root,
            force_sign=args.force_sign,
            sign_cert_chain=loaded_cert_chain,
            sign_key=sign_key,
            sign_key_passwd=sign_key_passwd,
        )
    except Exception as e:
        logger.debug(f"failed to sign the image: {e}", exc_info=e)
        exit_with_err_msg(f"failed to sign the image: {e}")

    if args.legacy_compat:
        logger.info(
            "Enable legacy OTA image compatibility, "
            "writing signed dummy metadata.jwt into OTA image ..."
        )
        _add_compat_to_image(
            image_root,
            cert_bytes=sign_cert_f.read_bytes(),
            sign_key=sign_key,
            sign_key_passwd=sign_key_passwd,
        )

    sign_cert = loaded_cert_chain.ee
    logger.info(
        (
            "OTA image is signed successfully with the following cert:\n"
            f"{sign_cert.issuer=}\n{sign_cert.subject=}\n{sign_cert.not_valid_before_utc=}\n{sign_cert.not_valid_after_utc=}"
        )
    )
    print("OTA image is signed successfully!")
